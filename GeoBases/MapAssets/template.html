<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" >
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="{{file_name}}" content="{{file_name}}" />

        <title>Map of "{{file_name}}"</title>
    </head>

    <body>
        <div id="canvas" style="width:1000px; height:700px">
        </div>

        <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
        <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
        <script type="text/javascript">
<!--
if (!String.fmt) {
    String.prototype.fmt = function() {
        var formatted = this;
        var i;
        for (i=0; i<arguments.length; i++) {
            var regexp = new RegExp('\\{'+i+'\\}', 'gi');
            formatted = formatted.replace(regexp, arguments[i]);
        }
        return formatted;
    };
}


function haversine(lat1, lng1, lat2, lng2) {

    lat1 = lat1 / 180 * Math.PI;
    lat2 = lat2 / 180 * Math.PI;
    lng1 = lng1 / 180 * Math.PI;
    lng2 = lng2 / 180 * Math.PI;

    return 2 * 6371.0 * Math.asin(Math.sqrt(
        Math.pow(Math.sin(0.5 * (lat1 - lat2)), 2) +
        Math.pow(Math.sin(0.5 * (lng1 - lng2)), 2) *
        Math.cos(lat1) * Math.cos(lat2)
    ));
}


function sortPointX(a, b) {
    return a.lng() - b.lng();
}


function sortPointY(a, b) {
    return a.lat() - b.lat();
}


function overflow(text) {

    if (typeof text === "number") {
        return text;
    }

    if (text.length < 30) {
        return text;
    }

    return ('' + text).slice(0, 25) + '...';

}


function initialize(jsonData) {

    // Set map options
    var parisLocation = new google.maps.LatLng(48.8, 2.33);

    var mapOptions = {
        zoom      : 2,
        center    : parisLocation,
        mapTypeId : google.maps.MapTypeId.ROADMAP
    };

    // Create the map
    var map = new google.maps.Map(
        document.getElementById("canvas"),
        mapOptions
    );

    if (jsonData.length === 0){
        return;
    }

    // Computing fields order
    var fields = [];
    var field;
    for (field in jsonData[0]) {
        if (jsonData[0].hasOwnProperty(field) && field !== '__lab__') {
            fields.push(field);
        }
    }

    fields.sort(function(a, b) {
        return b.toLowerCase() < a.toLowerCase();
    })

    var f = fields.length;
    var n = jsonData.length;

    var icon = '{{icon}}';

    var markersArray = [];
    var circlesArray = [];
    var centersArray = [];
    var bounds       = new google.maps.LatLngBounds();
    var infowindow   = new google.maps.InfoWindow();

    var i, j, c, e, s, latlng, marker, circle;
    var max_value = 0;

    // Load the data
    for (i=0 ; i<n ; i++) {

        e = jsonData[i];

        latlng = new google.maps.LatLng(e.lat, e.lng);

        if (isNaN(latlng.lat()) || isNaN(latlng.lng())) {
            //console.log(e.__lab__ + ' had no position: ' + e.lat + e.lng)
            continue;
        }

        marker = new google.maps.Marker({
            map         : map,
            position    : latlng,
            //animation   : google.maps.Animation.DROP,
            title       : e.__lab__,
            icon        : icon,
            clickable   : true,
            draggable   : false
        });

        // Augmenting the marker type
        marker.help = ' ' +
        '<div class="infowindow" style="min-width:400px; max-height:300px; overflow-y:auto;">' +
            '<h3>{0}</h3>'.fmt(e.__lab__) +
            '<table cellpadding="1">';

        for (j=0 ; j<f ; j++) {
            field = fields[j];
            marker.help += '<tr><td><i>{0}</i></td><td>{1}</td></tr>'.fmt(field, overflow(e[field]));
        }

        marker.help += ' ' +
            '</table>' +
        '</div>';

        google.maps.event.addListener(marker, 'click', function() {
            //infowindow.close(map, this);
            infowindow.setContent(this.help);
            infowindow.open(map, this);
        });

        // Saving marker
        markersArray.push(marker);
        bounds.extend(latlng);
        centersArray.push(latlng);

        // We compute the biggest __siz__ value
        s = parseFloat(e.__siz__);

        if ((! isNaN(s)) && s > 0) {
            if (s > max_value) {
                max_value = s;
            }
            circle = new google.maps.Circle({
                center          : latlng,
                radius          : 0,
                strokeColor     : "black",
                strokeOpacity   : 0.25,
                strokeWeight    : 2,
                fillColor       : "black",
                fillOpacity     : 0.15,
                map             : map,
                clickable       : true
            });

            // Augmenting the marker type
            circle.size = s
            circle.help = ' ' +
            '<div>' +
                '<h3>{0}</h3>'.fmt(e.__lab__) +
                '{0}'.fmt(s) +
            '</div>';

            // Saving
            circlesArray.push(circle);

            google.maps.event.addListener(circle, 'click', function(event) {
                //infowindow.close(map, this);
                infowindow.setContent(this.help);
                infowindow.open(map, new google.maps.Marker({position : event.latLng}));
            });

        }
    }

    // Ratio of map size for circles on the map
    //var R = 100;
    var r = 0.075;

    google.maps.event.addListener(map, 'bounds_changed', function() {
        // We compute the top radius given the map size
        var mapBounds = map.getBounds();
        var sw = mapBounds.getSouthWest();
        var ne = mapBounds.getNorthEast();

        var biggest = r * 1000 * haversine(sw.lat(), sw.lng(), ne.lat(), ne.lng());
        //var biggest = R * 1000;

        for (i=0, c=circlesArray.length; i<c; i++) {
            circle = circlesArray[i];
            circle.setRadius(Math.sqrt(circle.size / max_value) * biggest);
        }

    });

    // If no markers, we avoid a big
    // drift to the pacific ocean :)
    if (n >= 2) {
        map.fitBounds(bounds);
    }

    // Draw hull
    var hull = new google.maps.Polyline({
        path            : centersArray,
        strokeColor     : "green",
        strokeOpacity   : 0.40,
        strokeWeight    : 3,
        //fillColor       : "green",
        //fillOpacity     : 0,
        geodesic        : true,
        clickable       : false
    });


    // Control rightclick state
    var state = 0;
    var sortedCenters;

    google.maps.event.addListener(map, 'rightclick', function() {
        if (state === 0) {
            hull.setPath(centersArray);
            hull.setMap(map);

        } else if (state === 1) {
            sortedCenters = centersArray.slice();
            sortedCenters.sort(sortPointY);
            sortedCenters.sort(sortPointX);
            hull.setPath(sortedCenters);

        } else if (state === 2) {
            sortedCenters = centersArray.slice();
            sortedCenters.sort(sortPointX);
            sortedCenters.sort(sortPointY);
            hull.setPath(sortedCenters);

        } else if (state === 3) {
            hull.setMap(null);
        }

        state += 1;
        state = state === 4 ? 0 : state;
    });

}

$(document).ready(function() {

    $("#canvas").css({
        "height": $(window).height()*0.90
    });

    $("#canvas").css({
        "width": $(window).width()*0.99
    });

    $.getJSON(
        '{{json_file}}',
        function(data){
            initialize(data);
        }
    );

});
-->
        </script>
    </body>
</html>

