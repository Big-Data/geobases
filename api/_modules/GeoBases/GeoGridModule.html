

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>GeoBases.GeoGridModule &mdash; GeoBases 4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="GeoBases 4 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">GeoBases 4 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for GeoBases.GeoGridModule</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/python</span>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module is grid implementation, in order</span>
<span class="sd">to provide geographical indexation features.</span>

<span class="sd">    &gt;&gt;&gt; a = GeoGrid(radius=20)</span>
<span class="sd">    Setting grid precision to 4, avg radius to 20km</span>
<span class="sd">    &gt;&gt;&gt; a.add(&#39;ORY&#39;, (48.72, 2.359))</span>
<span class="sd">    &gt;&gt;&gt; a.add(&#39;CDG&#39;, (48.75, 2.361))</span>
<span class="sd">    &gt;&gt;&gt; list(a._findInAdjacentCases(encode(48.72, 2.359, a._precision), N=2))</span>
<span class="sd">    [&#39;ORY&#39;, &#39;CDG&#39;]</span>
<span class="sd">    &gt;&gt;&gt; a._keys[&#39;ORY&#39;]</span>
<span class="sd">    {&#39;case&#39;: &#39;u09t&#39;, &#39;lat_lng&#39;: (48.7..., 2.359)}</span>
<span class="sd">    &gt;&gt;&gt; neighbors(&#39;t0db&#39;)</span>
<span class="sd">    [&#39;t0d8&#39;, &#39;t0e0&#39;, &#39;t06z&#39;, &#39;t06x&#39;, &#39;t07p&#39;, &#39;t0dc&#39;, &#39;t0d9&#39;, &#39;t0e1&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(a._recursiveFrontier(&#39;t0dbr&#39;, N=2))</span>
<span class="sd">    [set([&#39;t0dbr&#39;]), set([&#39;t0e08&#39;, &#39;t0e00&#39;, &#39;t0dbn&#39;, &#39;t0e02&#39;, &#39;t0dbq&#39;, &#39;t0dbp&#39;, &#39;t0dbw&#39;, &#39;t0dbx&#39;])]</span>
<span class="sd">    &gt;&gt;&gt; list(a._recursiveFrontier(&#39;t0dbr&#39;, N=1))</span>
<span class="sd">    [set([&#39;t0dbr&#39;])]</span>
<span class="sd">    &gt;&gt;&gt; sum(len(f) for f in a._recursiveFrontier(&#39;t0dbr&#39;, N=2))</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt; sum(len(f) for f in a._recursiveFrontier(&#39;t0dbr&#39;, N=3))</span>
<span class="sd">    25</span>
<span class="sd">    &gt;&gt;&gt; sum(len(f) for f in a._recursiveFrontier(&#39;t0dbr&#39;, N=4))</span>
<span class="sd">    49</span>
<span class="sd">    &gt;&gt;&gt; sum(len(f) for f in a._recursiveFrontier(&#39;t0dbr&#39;, N=5))</span>
<span class="sd">    81</span>
<span class="sd">    &gt;&gt;&gt; list(a.findNearKey(&#39;ORY&#39;, 20))</span>
<span class="sd">    [(0, &#39;ORY&#39;), (0, &#39;CDG&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; list(a.findNearKey(&#39;ORY&#39;, 20, double_check=True))</span>
<span class="sd">    [(0.0, &#39;ORY&#39;), (3.33..., &#39;CDG&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; list(a.findClosestFromPoint((48.75, 2.361), N=2, double_check=True))</span>
<span class="sd">    [(0.0, &#39;CDG&#39;), (3.33..., &#39;ORY&#39;)]</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">geohash</span> <span class="kn">import</span> <span class="n">encode</span><span class="p">,</span> <span class="n">neighbors</span>

<span class="kn">from</span> <span class="nn">.GeoUtils</span> <span class="kn">import</span> <span class="n">haversine</span>


<span class="c"># Max recursion when iterating on frontiers</span>
<span class="n">MAX_RECURSIVE_FRONTIER</span> <span class="o">=</span> <span class="mi">5000</span>

<span class="c"># Thanks wikipedia</span>
<span class="c"># hash length | lat bits | lng bits | lat error | lng error | km error</span>
<span class="n">HASH_TO_ERROR</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">23</span><span class="p">,</span>       <span class="mi">23</span><span class="p">,</span>      <span class="mi">2500</span><span class="p">),</span>
    <span class="mi">2</span> <span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mf">2.8</span><span class="p">,</span>      <span class="mf">5.6</span><span class="p">,</span>     <span class="mi">630</span><span class="p">),</span>
    <span class="mi">3</span> <span class="p">:</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mf">0.70</span><span class="p">,</span>     <span class="mf">0.7</span><span class="p">,</span>     <span class="mi">78</span><span class="p">),</span>
    <span class="mi">4</span> <span class="p">:</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.087</span><span class="p">,</span>    <span class="mf">0.18</span><span class="p">,</span>    <span class="mi">20</span><span class="p">),</span>
    <span class="mi">5</span> <span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mf">0.022</span><span class="p">,</span>    <span class="mf">0.022</span><span class="p">,</span>   <span class="mf">2.4</span><span class="p">),</span>
    <span class="mi">6</span> <span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mf">0.0027</span><span class="p">,</span>   <span class="mf">0.0055</span><span class="p">,</span>  <span class="mf">0.61</span><span class="p">),</span>
    <span class="mi">7</span> <span class="p">:</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mf">0.00068</span><span class="p">,</span>  <span class="mf">0.00068</span><span class="p">,</span> <span class="mf">0.076</span><span class="p">),</span>
    <span class="mi">8</span> <span class="p">:</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">0.000085</span><span class="p">,</span> <span class="mf">0.00017</span><span class="p">,</span> <span class="mf">0.019</span><span class="p">)</span>
<span class="p">}</span>


<div class="viewcode-block" id="GeoGrid"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid">[docs]</a><span class="k">class</span> <span class="nc">GeoGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the main and only class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GeoGrid.__init__"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates grid.</span>

<span class="sd">        :param radius:    the grid accuracy, in kilometers</span>
<span class="sd">        :param precision: the hash length, if radius is given, this length is \</span>
<span class="sd">                computed from the radius</span>
<span class="sd">        :param verbose:   toggle verbosity</span>
<span class="sd">        :returns:         None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">get_error</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">,</span>  <span class="nb">abs</span><span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]))</span>
            <span class="c"># Tricky, min of values only positive here</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">HASH_TO_ERROR</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">get_error</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_precision</span>  <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_avg_radius</span> <span class="o">=</span> <span class="n">HASH_TO_ERROR</span><span class="p">[</span><span class="n">precision</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>

        <span class="c"># Double mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Setting grid precision to </span><span class="si">%s</span><span class="s">, avg radius to </span><span class="si">%s</span><span class="s">km&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avg_radius</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_computeCaseId</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computing the id the case for a (lat, lng).</span>

<span class="sd">        :param lat_lng: the lat_lng of the point (a tuple of (lat, lng))</span>
<span class="sd">        :returns:       the case_id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">encode</span><span class="p">(</span><span class="o">*</span><span class="n">lat_lng</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_precision</span><span class="p">)</span>



<div class="viewcode-block" id="GeoGrid.add"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a point to the grid.</span>

<span class="sd">        :param key:     the key to be added</span>
<span class="sd">        :param lat_lng: the lat_lng of the point (a tuple of (lat, lng))</span>
<span class="sd">        :param verbose: toggle verbosity</span>
<span class="sd">        :returns:       None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">case_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computeCaseId</span><span class="p">(</span><span class="n">lat_lng</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
            <span class="c"># TypeError for wrong type (NoneType, str)</span>
            <span class="c"># Exception for invalid coordinates</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;Wrong coordinates </span><span class="si">%s</span><span class="s"> for key </span><span class="si">%s</span><span class="s">, skipping point.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lat_lng</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;case&#39;</span>    <span class="p">:</span> <span class="n">case_id</span><span class="p">,</span>
            <span class="s">&#39;lat_lng&#39;</span> <span class="p">:</span> <span class="n">lat_lng</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">case_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">case_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">case_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


</div>
    <span class="k">def</span> <span class="nf">_recursiveFrontier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">case_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the successive frontiers from a case.</span>
<span class="sd">        A frontier is a set of case ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

        <span class="n">frontier</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">case_id</span><span class="p">])</span>
        <span class="n">interior</span> <span class="o">=</span> <span class="n">frontier</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">MAX_RECURSIVE_FRONTIER</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;/!\ Recursion exceeded in recursiveFrontier&#39;</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span>

            <span class="k">yield</span> <span class="n">frontier</span>

            <span class="n">frontier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextFrontier</span><span class="p">(</span><span class="n">frontier</span><span class="p">,</span> <span class="n">interior</span><span class="p">)</span>
            <span class="n">interior</span> <span class="o">=</span> <span class="n">interior</span> <span class="o">|</span> <span class="n">frontier</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_nextFrontier</span><span class="p">(</span><span class="n">frontier</span><span class="p">,</span> <span class="n">interior</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute next frontier from a frontier and a </span>
<span class="sd">        matching interior.</span>
<span class="sd">        Interior is the set of case ids in the frontier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">frontier</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interior</span><span class="p">])</span>



    <span class="k">def</span> <span class="nf">_check_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">ref_lat_lng</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter from a iterator of candidates, the ones </span>
<span class="sd">        who are within a radius if a ref_lat_lng.</span>

<span class="sd">        Yields the good ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">can</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">:</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine</span><span class="p">(</span><span class="n">ref_lat_lng</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">can</span><span class="p">][</span><span class="s">&#39;lat_lng&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">can</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_allKeysInCases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cases</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yields all keys in a iterable of case ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">case_id</span> <span class="ow">in</span> <span class="n">cases</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">case_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">case_id</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">key</span>


    <span class="k">def</span> <span class="nf">_findInAdjacentCases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">case_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find keys in adjacent cases from a case_id.</span>
<span class="sd">        Yields found keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">frontier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursiveFrontier</span><span class="p">(</span><span class="n">case_id</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allKeysInCases</span><span class="p">(</span><span class="n">frontier</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">key</span>


    <span class="k">def</span> <span class="nf">_findNearCase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">case_id</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as _findInAdjacentCases, but the limitation</span>
<span class="sd">        is given with a radius and not with a recursive limit</span>
<span class="sd">        in adjacency computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Do your homework :D</span>
        <span class="c"># A more accurate formula would be with</span>
        <span class="c"># self._avg_radius = min(r1, r2) where r1 are r2 are</span>
        <span class="c"># the size of one case</span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avg_radius</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avg_radius</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findInAdjacentCases</span><span class="p">(</span><span class="n">case_id</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>



<div class="viewcode-block" id="GeoGrid.findNearPoint"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid.findNearPoint">[docs]</a>    <span class="k">def</span> <span class="nf">findNearPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">double_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of nearby things from a point (given</span>
<span class="sd">        latidude and longitude), and a radius for the search.</span>
<span class="sd">        Note that the haversine function, which compute distance</span>
<span class="sd">        at the surface of a sphere, here returns kilometers,</span>
<span class="sd">        so the radius should be in kms.</span>

<span class="sd">        :param lat_lng: the lat_lng of the point (a tuple of (lat, lng))</span>
<span class="sd">        :param radius:  the radius of the search (kilometers)</span>
<span class="sd">        :param double_check: when using grid, perform an additional check on results distance, \</span>
<span class="sd">            this is useful because the grid is approximate, so the results are only as accurate \</span>
<span class="sd">            as the grid size</span>
<span class="sd">        :returns:       an iterable of (distance, key) like [(3.2, &#39;SFO&#39;), (4.5, &#39;LAX&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lat_lng</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Case where the lat_lng was missing from base</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

        <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findNearCase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_computeCaseId</span><span class="p">(</span><span class="n">lat_lng</span><span class="p">),</span> <span class="n">radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">double_check</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_distance</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">can</span><span class="p">)</span> <span class="k">for</span> <span class="n">can</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="GeoGrid.findNearKey"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid.findNearKey">[docs]</a>    <span class="k">def</span> <span class="nf">findNearKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">double_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as findNearPoint, except the point is given</span>
<span class="sd">        not by a lat/lng, but with its key, like ORY or SFO.</span>
<span class="sd">        We just look up in the base to retrieve lat/lng, and</span>
<span class="sd">        call findNearPoint.</span>

<span class="sd">        :param key:     the key</span>
<span class="sd">        :param radius:  the radius of the search (kilometers)</span>
<span class="sd">        :param double_check: when using grid, perform an additional check on results distance, \</span>
<span class="sd">            this is useful because the grid is approximate, so the results are only as accurate \</span>
<span class="sd">            as the grid size</span>
<span class="sd">        :returns:       an iterable of (distance, key) like [(3.2, &#39;SFO&#39;), (4.5, &#39;LAX&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">:</span>
            <span class="c"># Case where the key probably did not have a proper geocode </span>
            <span class="c"># and as such was never indexed</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([])</span>

        <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findNearCase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;case&#39;</span><span class="p">],</span> <span class="n">radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">double_check</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_distance</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s">&#39;lat_lng&#39;</span><span class="p">],</span> <span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">can</span><span class="p">)</span> <span class="k">for</span> <span class="n">can</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="GeoGrid.findClosestFromPoint"><a class="viewcode-back" href="../../GeoBases.html#GeoBases.GeoGridModule.GeoGrid.findClosestFromPoint">[docs]</a>    <span class="k">def</span> <span class="nf">findClosestFromPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">double_check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">from_keys</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concept close to findNearPoint, but here we do not</span>
<span class="sd">        look for the things radius-close to a point,</span>
<span class="sd">        we look for the closest thing from this point, given by</span>
<span class="sd">        latitude/longitude.</span>

<span class="sd">        Note that a similar implementation is done in</span>
<span class="sd">        the LocalHelper, to find efficiently N closest point</span>
<span class="sd">        in a graph, from a point (using heaps).</span>

<span class="sd">        :param lat_lng:   the lat_lng of the point (a tuple of (lat, lng))</span>
<span class="sd">        :param N:         the N closest results wanted</span>
<span class="sd">        :param from_keys: if None, it takes all keys in consideration, else takes from_keys \</span>
<span class="sd">            iterable of keys to perform findClosestFromPoint. This is useful when we have names \</span>
<span class="sd">            and have to perform a matching based on name and location (see fuzzyGetAroundLatLng).</span>
<span class="sd">        :param double_check: when using grid, perform an additional check on results distance, \</span>
<span class="sd">            this is useful because the grid is approximate, so the results are only as accurate \</span>
<span class="sd">            as the grid size</span>
<span class="sd">        :returns:       an iterable of (distance, key) like [(3.2, &#39;SFO&#39;), (4.5, &#39;LAX&#39;)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">from_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># We convert to set before testing to nullity</span>
            <span class="c"># because of empty iterators</span>
            <span class="n">from_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">from_keys</span><span class="p">)</span>

            <span class="c"># If from_keys is empty, the result is obvious</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">from_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c"># We cannot give what we do not have</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">from_keys</span><span class="p">))</span>

        <span class="c"># Some precaution for the number of wanted keys</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">))</span>

        <span class="c"># The case of the point</span>
        <span class="n">case_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computeCaseId</span><span class="p">(</span><span class="n">lat_lng</span><span class="p">)</span>

        <span class="n">found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">frontier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursiveFrontier</span><span class="p">(</span><span class="n">case_id</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

            <span class="n">found</span> <span class="o">=</span> <span class="n">found</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allKeysInCases</span><span class="p">(</span><span class="n">frontier</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">from_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># If from_keys is empty this will turn</span>
                <span class="c"># into an infinite loop</span>
                <span class="c"># stopped by MAX_RECURSIVE_FRONTIER</span>
                <span class="c"># This should not happen since we treated that case</span>
                <span class="c"># at the beginning</span>
                <span class="n">found</span> <span class="o">=</span> <span class="n">found</span> <span class="o">&amp;</span> <span class="n">from_keys</span>

            <span class="c"># Heuristic</span>
            <span class="c"># We have to compare the distance of the farthest found</span>
            <span class="c"># against the distance really covered by the search</span>
            <span class="c">#print frontier</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">double_check</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_distance</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">lat_lng</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)))[:</span><span class="n">N</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">found</span><span class="p">)</span>



</div></div>
<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When called directly, launching doctests.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="n">extraglobs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">opt</span> <span class="o">=</span>  <span class="p">(</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span>
            <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span> <span class="o">|</span>
            <span class="n">doctest</span><span class="o">.</span><span class="n">REPORT_ONLY_FIRST_FAILURE</span> <span class="o">|</span>
            <span class="n">doctest</span><span class="o">.</span><span class="n">IGNORE_EXCEPTION_DETAIL</span><span class="p">)</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">extraglobs</span><span class="o">=</span><span class="n">extraglobs</span><span class="p">,</span> <span class="n">optionflags</span><span class="o">=</span><span class="n">opt</span><span class="p">)</span>



<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">GeoBases 4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, OpenTravelData.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>